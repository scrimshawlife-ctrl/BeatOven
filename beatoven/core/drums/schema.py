"""
BeatOven Drums Schema

Data models for RigProfile, PercussionTopology, and PatternTokens.
Defines equipment constraints and percussion allocation strategy.

ABX-Core compliant with provenance tracking and deterministic serialization.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, List, Literal, Optional, Tuple
from enum import Enum
import hashlib
import json


# ==================== ENUMS ====================

class EmitTarget(str, Enum):
    """Hardware output target type."""
    DSP_COFFEE = "dsp_coffee"
    MIDI = "midi"
    CV_GATE = "cv_gate"
    AUDIO_STEMS = "audio_stems"


class CVRange(str, Enum):
    """CV voltage range."""
    ZERO_5V = "0_5"          # 0-5V (Eurorack standard)
    NEG5_5V = "neg5_5"       # -5V to +5V (bipolar)
    ZERO_10V = "0_10"        # 0-10V (Buchla/Serge)


class SwingSource(str, Enum):
    """Source of swing/groove timing."""
    INTERNAL = "internal"     # Generated by BeatOven
    EXTERNAL = "external"     # From hardware clock
    HYBRID = "hybrid"         # Combination


class DrumRole(str, Enum):
    """Semantic role of a drum lane."""
    KICK = "kick"
    SNARE = "snare"
    HAT = "hat"             # Hi-hat (closed/open)
    PERC = "perc"           # Percussion (toms, cymbals, etc.)
    FX = "fx"               # Sound effects, noise


# ==================== HELPER FUNCTIONS ====================

def _stable_hash(obj: Any) -> str:
    """Generate deterministic SHA256 hash of object."""
    payload = json.dumps(obj, sort_keys=True, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
    return hashlib.sha256(payload).hexdigest()


def _clamp(x: float, lo: float, hi: float) -> float:
    """Clamp value to range."""
    return lo if x < lo else hi if x > hi else float(x)


# ==================== RIG PROFILE ====================

@dataclass(frozen=True)
class IOCapabilities:
    """I/O capabilities of the hardware rig."""
    trigger: bool = True         # Can send gate triggers
    gate: bool = True            # Can send sustained gates
    accent: bool = False         # Supports accent/velocity modulation
    velocity: bool = False       # Supports MIDI-style velocity (0-127)
    cv_range: CVRange = CVRange.ZERO_5V

    def to_dict(self) -> Dict[str, Any]:
        return {
            "trigger": self.trigger,
            "gate": self.gate,
            "accent": self.accent,
            "velocity": self.velocity,
            "cv_range": self.cv_range.value
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "IOCapabilities":
        return IOCapabilities(
            trigger=data.get("trigger", True),
            gate=data.get("gate", True),
            accent=data.get("accent", False),
            velocity=data.get("velocity", False),
            cv_range=CVRange(data.get("cv_range", "0_5"))
        )


@dataclass(frozen=True)
class ClockingConfig:
    """Clocking and synchronization configuration."""
    external_clock: bool = False
    external_reset: bool = False
    swing_source: SwingSource = SwingSource.INTERNAL

    def to_dict(self) -> Dict[str, Any]:
        return {
            "external_clock": self.external_clock,
            "external_reset": self.external_reset,
            "swing_source": self.swing_source.value
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "ClockingConfig":
        return ClockingConfig(
            external_clock=data.get("external_clock", False),
            external_reset=data.get("external_reset", False),
            swing_source=SwingSource(data.get("swing_source", "internal"))
        )


@dataclass(frozen=True)
class OutputMapping:
    """Maps a drum lane to a physical output."""
    lane_index: int
    role: DrumRole
    out_id: str  # e.g., "trigger_1", "midi_ch_10_note_36", "cv_a"

    def to_dict(self) -> Dict[str, Any]:
        return {
            "lane_index": self.lane_index,
            "role": self.role.value,
            "out_id": self.out_id
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "OutputMapping":
        return OutputMapping(
            lane_index=data["lane_index"],
            role=DrumRole(data["role"]),
            out_id=data["out_id"]
        )


@dataclass(frozen=True)
class RigProfile:
    """
    Equipment profile defining hardware constraints for percussion generation.

    This profile constrains the topology allocator and pattern composer to only
    generate outputs compatible with the user's hardware setup.

    Immutable by design for cache safety and provenance tracking.
    """
    id: str
    name: str
    emit_target: EmitTarget
    drum_lanes_max: int  # Maximum number of simultaneous drum lanes (1-16)

    # Semantic roles allowed for this rig
    lane_roles_allowed: Tuple[DrumRole, ...] = (
        DrumRole.KICK, DrumRole.SNARE, DrumRole.HAT, DrumRole.PERC, DrumRole.FX
    )

    io_caps: IOCapabilities = field(default_factory=IOCapabilities)
    clocking: ClockingConfig = field(default_factory=ClockingConfig)

    # Optional explicit output mapping (if None, auto-assigned)
    output_map: Optional[Tuple[OutputMapping, ...]] = None

    # Metadata (monotonic timestamp, not used in deterministic computations)
    created_at_ts_ms: Optional[int] = None

    def __post_init__(self):
        """Validate constraints."""
        if self.drum_lanes_max < 1 or self.drum_lanes_max > 16:
            raise ValueError(f"drum_lanes_max must be 1-16, got {self.drum_lanes_max}")
        if len(self.lane_roles_allowed) == 0:
            raise ValueError("lane_roles_allowed cannot be empty")
        if self.output_map is not None and len(self.output_map) > self.drum_lanes_max:
            raise ValueError("output_map cannot exceed drum_lanes_max")

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary (stable, sorted)."""
        return {
            "id": self.id,
            "name": self.name,
            "emit_target": self.emit_target.value,
            "drum_lanes_max": self.drum_lanes_max,
            "lane_roles_allowed": sorted([r.value for r in self.lane_roles_allowed]),
            "io_caps": self.io_caps.to_dict(),
            "clocking": self.clocking.to_dict(),
            "output_map": [m.to_dict() for m in self.output_map] if self.output_map else None,
            "created_at_ts_ms": self.created_at_ts_ms
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "RigProfile":
        """Deserialize from dictionary."""
        return RigProfile(
            id=data["id"],
            name=data["name"],
            emit_target=EmitTarget(data["emit_target"]),
            drum_lanes_max=data["drum_lanes_max"],
            lane_roles_allowed=tuple(DrumRole(r) for r in data.get("lane_roles_allowed", ["kick", "snare", "hat", "perc", "fx"])),
            io_caps=IOCapabilities.from_dict(data.get("io_caps", {})),
            clocking=ClockingConfig.from_dict(data.get("clocking", {})),
            output_map=tuple(OutputMapping.from_dict(m) for m in data["output_map"]) if data.get("output_map") else None,
            created_at_ts_ms=data.get("created_at_ts_ms")
        )

    def config_hash(self) -> str:
        """
        Deterministic hash of configuration (excludes timestamp).
        Used in provenance tracking.
        """
        core = {
            "id": self.id,
            "emit_target": self.emit_target.value,
            "drum_lanes_max": self.drum_lanes_max,
            "lane_roles_allowed": sorted([r.value for r in self.lane_roles_allowed]),
            "io_caps": self.io_caps.to_dict(),
            "clocking": self.clocking.to_dict(),
            "output_map": [m.to_dict() for m in self.output_map] if self.output_map else None
        }
        return _stable_hash(core)


# ==================== PERCUSSION TOPOLOGY ====================

@dataclass(frozen=True)
class DrumLane:
    """
    A single drum lane in the percussion topology.

    Represents one concurrent drum voice with allocated density budget,
    semantic role, and output mapping.
    """
    lane_id: str  # Unique within topology (e.g., "lane_0_kick")
    role: DrumRole
    density_budget: float  # 0.0-1.0, how dense this lane should be
    syncopation_budget: float  # 0.0-1.0, how much off-beat emphasis
    accent_support: bool  # Whether accents are enabled for this lane
    out_map: Optional[OutputMapping] = None  # Physical output assignment

    # Explanation for why this lane was allocated (for UI display)
    allocation_reason: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "lane_id": self.lane_id,
            "role": self.role.value,
            "density_budget": self.density_budget,
            "syncopation_budget": self.syncopation_budget,
            "accent_support": self.accent_support,
            "out_map": self.out_map.to_dict() if self.out_map else None,
            "allocation_reason": self.allocation_reason
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "DrumLane":
        return DrumLane(
            lane_id=data["lane_id"],
            role=DrumRole(data["role"]),
            density_budget=data["density_budget"],
            syncopation_budget=data["syncopation_budget"],
            accent_support=data["accent_support"],
            out_map=OutputMapping.from_dict(data["out_map"]) if data.get("out_map") else None,
            allocation_reason=data.get("allocation_reason")
        )


@dataclass(frozen=True)
class PercussionTopology:
    """
    Percussion topology: allocation of drum lanes with budgets.

    This is the output of the LaneAllocator engine. It defines HOW MANY lanes,
    WHICH roles, and WHAT density budgets, constrained by the RigProfile.

    The PatternComposer then generates actual patterns from this topology.
    """
    rig_profile_id: str
    bpm: Optional[float] = None  # Optional BPM hint
    meter: Tuple[int, int] = (4, 4)  # Time signature

    lanes: Tuple[DrumLane, ...] = field(default_factory=tuple)

    # Global constraints
    global_density_cap: float = 1.0  # 0.0-1.0, overall density limit
    syncopation_budget: float = 0.5  # 0.0-1.0, how much syncopation allowed
    fill_policy: Literal["none", "sparse", "moderate", "dense"] = "moderate"

    # Provenance
    provenance_hash: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary (stable, sorted)."""
        return {
            "rig_profile_id": self.rig_profile_id,
            "bpm": self.bpm,
            "meter": list(self.meter),
            "lanes": [lane.to_dict() for lane in self.lanes],
            "global_density_cap": self.global_density_cap,
            "syncopation_budget": self.syncopation_budget,
            "fill_policy": self.fill_policy,
            "provenance_hash": self.provenance_hash
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "PercussionTopology":
        """Deserialize from dictionary."""
        return PercussionTopology(
            rig_profile_id=data["rig_profile_id"],
            bpm=data.get("bpm"),
            meter=tuple(data.get("meter", [4, 4])),
            lanes=tuple(DrumLane.from_dict(l) for l in data.get("lanes", [])),
            global_density_cap=data.get("global_density_cap", 1.0),
            syncopation_budget=data.get("syncopation_budget", 0.5),
            fill_policy=data.get("fill_policy", "moderate"),
            provenance_hash=data.get("provenance_hash")
        )

    def with_provenance_hash(self, seed: int, input_hash: str, code_version: str) -> "PercussionTopology":
        """
        Return new topology with computed provenance hash.

        Args:
            seed: RNG seed used in allocation
            input_hash: Hash of input (ResonanceFrame + RigProfile)
            code_version: Version of allocator code
        """
        core = {
            "topology": self.to_dict(),
            "seed": seed,
            "input_hash": input_hash,
            "code_version": code_version
        }
        ph = _stable_hash(core)
        return PercussionTopology(
            rig_profile_id=self.rig_profile_id,
            bpm=self.bpm,
            meter=self.meter,
            lanes=self.lanes,
            global_density_cap=self.global_density_cap,
            syncopation_budget=self.syncopation_budget,
            fill_policy=self.fill_policy,
            provenance_hash=ph
        )


# ==================== PATTERN TOKENS ====================

@dataclass(frozen=True)
class LanePattern:
    """Pattern for a single drum lane."""
    lane_id: str
    role: DrumRole
    steps: Tuple[float, ...]  # Step grid, values in [0, 1] (probability/velocity)
    accents: Tuple[bool, ...]  # Accent flags per step
    resolution: float = 0.25  # Step resolution in beats (e.g., 0.25 = 16th notes)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "lane_id": self.lane_id,
            "role": self.role.value,
            "steps": list(self.steps),
            "accents": list(self.accents),
            "resolution": self.resolution
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "LanePattern":
        return LanePattern(
            lane_id=data["lane_id"],
            role=DrumRole(data["role"]),
            steps=tuple(data["steps"]),
            accents=tuple(data["accents"]),
            resolution=data.get("resolution", 0.25)
        )


@dataclass(frozen=True)
class PatternTokens:
    """
    Pattern tokens: concrete step grids for each lane.

    This is the output of the PatternComposer engine. It contains the actual
    note probabilities/velocities and accents for each drum lane.

    Can be consumed by RhythmEngine or dsp.coffee bridge.
    """
    bpm: float
    meter: Tuple[int, int] = (4, 4)
    length_bars: int = 4

    lane_patterns: Tuple[LanePattern, ...] = field(default_factory=tuple)

    # Global pattern properties
    swing_amount: float = 0.0  # 0.0-1.0
    humanize_amount: float = 0.0  # 0.0-1.0, timing/velocity variation

    # Provenance
    provenance_hash: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary (stable, sorted)."""
        return {
            "bpm": self.bpm,
            "meter": list(self.meter),
            "length_bars": self.length_bars,
            "lane_patterns": [lp.to_dict() for lp in self.lane_patterns],
            "swing_amount": self.swing_amount,
            "humanize_amount": self.humanize_amount,
            "provenance_hash": self.provenance_hash
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> "PatternTokens":
        """Deserialize from dictionary."""
        return PatternTokens(
            bpm=data["bpm"],
            meter=tuple(data.get("meter", [4, 4])),
            length_bars=data.get("length_bars", 4),
            lane_patterns=tuple(LanePattern.from_dict(lp) for lp in data.get("lane_patterns", [])),
            swing_amount=data.get("swing_amount", 0.0),
            humanize_amount=data.get("humanize_amount", 0.0),
            provenance_hash=data.get("provenance_hash")
        )

    def with_provenance_hash(self, seed: int, input_hash: str, code_version: str) -> "PatternTokens":
        """
        Return new pattern with computed provenance hash.

        Args:
            seed: RNG seed used in composition
            input_hash: Hash of input (PercussionTopology)
            code_version: Version of composer code
        """
        core = {
            "pattern": self.to_dict(),
            "seed": seed,
            "input_hash": input_hash,
            "code_version": code_version
        }
        ph = _stable_hash(core)
        return PatternTokens(
            bpm=self.bpm,
            meter=self.meter,
            length_bars=self.length_bars,
            lane_patterns=self.lane_patterns,
            swing_amount=self.swing_amount,
            humanize_amount=self.humanize_amount,
            provenance_hash=ph
        )


__all__ = [
    "EmitTarget",
    "CVRange",
    "SwingSource",
    "DrumRole",
    "IOCapabilities",
    "ClockingConfig",
    "OutputMapping",
    "RigProfile",
    "DrumLane",
    "PercussionTopology",
    "LanePattern",
    "PatternTokens",
]
